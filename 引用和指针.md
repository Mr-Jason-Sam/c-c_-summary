# 引用和指针
* 如何交换两个字符串

	```
	//通过指针引用传入指针的地址
	void swap(char *&x, char *&y){
		char *temp = x;
		x = y;
		y = temp;
	}
	//通过二级指针传入指针的地址
	void swap(char **x, char **y){
		char *temp = *x;
		*x = *y;
		*y = temp;
	}
	```
**注意：假设不使用指针引用或者二级指针的话，函数体的函数栈会分配两个临时变量分别指向两个指针参数，对实际调用的实参不产生任何影响**

* 指针和引用的区别

	|   | 指针  | 引用 |
	|:------------- |:---------------:| :-------------:|
	| 初始化      | 可不初始化，可为NULL |  必须初始化，不存在NULL|
	| 修改性      | 随时修改        |           不可修改 |
	| 测试 |    检查空的指针和野指针     |  不需要检查合法性   |
	| 效率 | 低        |            高 |
	
* this指针基本概念:`类的非静态成员才有this指针`
* 指针数组和数组指针
	> `指针数组`：是一个数组，数组中每个元素是一个指针，且指针指向数组。<br>
	> `数组指针`：是一个指针，指向一个数组的指针。
* 函数指针和指针函数
	> `指针函数`：返回指针类型的函数。<br>
	> `函数指针`：指向函数的指针，可用该指针调用函数。
* 杜绝野指针的危险：`需要动态分配内存或者赋值为NULL`
* malloc/free和new/delete的区别
	> `malloc/free`：对于非内部数据类型，对象在创建的时候执行构造函数，在消亡时执行析构函数，由于malloc/free是库函数而不是运算符，不在编译器的控制权限之内，不能把构造和析构的任务强加于malloc/free。<br>
	> `new/delete`：是运算符，可被编译器执行构造和析构操作。
* 内存分配中的方式
	> `堆`：动态分配内存，malloc/free、new/delete，但多次分配和销毁会造成外部碎片。<br>
	> `栈`：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。<br>
	> `静态储存区/全局变量区`：在程序编译阶段已经分配好的内存，生命周期在程序运行阶段<br>
	> `常量区`：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改<br>
	> `自由存储区`：就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的
